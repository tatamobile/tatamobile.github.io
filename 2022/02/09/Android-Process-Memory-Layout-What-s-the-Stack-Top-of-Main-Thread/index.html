<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>Android进程内存布局：主线程的栈顶是多少？ | TATAMOBILE</title>
  <meta name="author" content="TATAMOBILE">
  
  <meta name="description" content="Machine Learning, Anroid, iOS, Reverse Engineering">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Android进程内存布局：主线程的栈顶是多少？"/>
  <meta property="og:site_name" content="TATAMOBILE"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-FXZ3M3DJK6"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-FXZ3M3DJK6');
</script>


  
<!-- Google Adsense -->
<!-- <script data-ad-client="ca-pub-6011041061943855" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> -->

  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">TATAMOBILE</a></h1>
  <h2><a href="/">An information tech&#39;s blog</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-Android-Process-Memory-Layout-What-s-the-Stack-Top-of-Main-Thread" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2022-02-09T09:10:09.000Z"><a href="/2022/02/09/Android-Process-Memory-Layout-What-s-the-Stack-Top-of-Main-Thread/">2022-02-09</a></time>
        
  
    <h1 class="p-name title" itemprop="headline name">Android进程内存布局：主线程的栈顶是多少？</h1>
  

      
    </header>
    <div class="e-content entry" itemprop="articleBody">
        
      
        <!-- Table of Contents -->
        
        <h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近开发一个基于unicron的模拟执行库，为了更好地模拟进程和线程的一些特性（比如线程本地存储），需要知道Android进程的实际内存布局，这里主要介绍线程栈的布局，非主线程可以通过分析pthread_create实现过程，了解到线程栈是通过mmap分配内存得到的，并且大小是1M。那主线程的栈位于哪里呢？一般进程内存布局如下图：</p>
<img src="/images/android_process_mem_layout.png" class="">

<p>在32位系统里，4G虚拟内存空间内核占用1G，用户空间占用3G，推测主线程的栈顶就是0xc0000000。可以通过”/proc/pid/maps” 查看详细的内存分布：</p>
<img src="/images/android-mem-layout-maps.png" class="">

<p>从图中可以看出主线程栈顶是0xbea5a000。</p>
<h2 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h2><p>“0xbea5a000” 是如何计算出来的？在linux中进程创建通常通过fork和execv两个系统调用配合完成。可通过阅读内核关于这两个系统调用的源码来理解栈的分配逻辑。这里不详述fork和execv的执行逻辑，与栈相关的代码在fs/binfmt.c里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STACK_RND_MASK</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_RND_MASK (0x7ff &gt;&gt; (PAGE_SHIFT - 12))	<span class="comment">/* 8MB of VA */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">randomize_stack_top</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> random_variable = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((current-&gt;flags &amp; PF_RANDOMIZE) &amp;&amp;</span><br><span class="line">		!(current-&gt;personality &amp; ADDR_NO_RANDOMIZE)) &#123;</span><br><span class="line">		random_variable = get_random_int() &amp; STACK_RND_MASK;</span><br><span class="line">		random_variable &lt;&lt;= PAGE_SHIFT;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_STACK_GROWSUP</span></span><br><span class="line">	<span class="keyword">return</span> PAGE_ALIGN(stack_top) + random_variable;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">return</span> PAGE_ALIGN(stack_top) - random_variable;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程的栈顶不是固定的，有一个随机范围 0 ~ 8M。那代码中的stack_top是多少呢？<br>函数 “randomize_stack_top” 在 “load_elf_binary”里被调用。<br>load_elf_binary 代码片段 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Do this immediately, since STACK_TOP as used in setup_arg_pages</span></span><br><span class="line"><span class="comment">	   may depend on the personality.  */</span></span><br><span class="line">	SET_PERSONALITY(loc-&gt;elf_ex);</span><br><span class="line">	<span class="keyword">if</span> (elf_read_implies_exec(loc-&gt;elf_ex, executable_stack))</span><br><span class="line">		current-&gt;personality |= READ_IMPLIES_EXEC;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(current-&gt;personality &amp; ADDR_NO_RANDOMIZE) &amp;&amp; randomize_va_space)</span><br><span class="line">		current-&gt;flags |= PF_RANDOMIZE;</span><br><span class="line"></span><br><span class="line">	setup_new_exec(bprm);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do this so that we can load the interpreter, if need be.  We will</span></span><br><span class="line"><span class="comment">	   change some of these later */</span></span><br><span class="line">	current-&gt;mm-&gt;free_area_cache = current-&gt;mm-&gt;mmap_base;</span><br><span class="line">	current-&gt;mm-&gt;cached_hole_size = <span class="number">0</span>;</span><br><span class="line">	retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),</span><br><span class="line">				 executable_stack);</span><br></pre></td></tr></table></figure>

<p>“STACK_TOP”是一个宏定义，详细定义在文件”arch/arm/include/asm/processor.h”里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __KERNEL__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_TOP	((current-&gt;personality &amp; ADDR_LIMIT_32BIT) ? \</span></span><br><span class="line">			 TASK_SIZE : TASK_SIZE_26)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_TOP_MAX	TASK_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>“TASK_SIZE”宏定义在”arch/arm/include/asm/memory.h”里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PAGE_OFFSET - the virtual address of the start of the kernel image</span></span><br><span class="line"><span class="comment"> * TASK_SIZE - the maximum size of a user space task.</span></span><br><span class="line"><span class="comment"> * TASK_UNMAPPED_BASE - the lower boundary of the mmap VM area</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_OFFSET		UL(CONFIG_PAGE_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_SIZE		(UL(CONFIG_PAGE_OFFSET) - UL(0x01000000))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_UNMAPPED_BASE	(UL(CONFIG_PAGE_OFFSET) / 3)</span></span><br></pre></td></tr></table></figure>

<p>从上述代码可知，一般情况下，PAGE_OFFSET 是内核空间的开始地址0xC0000000，TASK_SIZE(即STACK_TOP)是用户空间的结束地址，与PAGE_OFFSET有一个16M的间隔，即STACK_TOP的值是0xBF000000。从函数 “randomize_stack_top”可知，在STACK_TOP上还有0～8M的随机。由此可知，主线程栈顶的值在范围[0xBE800000,0xBF000000]内。文章开头提到的0xBEA5A000属于这个范围，多观察几台手机的主线程栈顶都在这个范围，符合预期。</p>
<p>到目前为止，我们已经解决了文章开头提到的问题，不过在探索过程中又出现了3个新问题：</p>
<ul>
<li>STACK_TOP和PAGE_OFFSET 之间间隔的16M地址空间有什么用处呢？</li>
<li>在观察进程内存情况时，处于内核空间的[0xFFFF0000,0xFFFF1000]这一块地址空间主要用来做什么呢？</li>
<li>在主线程栈顶附近的数据到底是什么？</li>
</ul>
<p>后续三个小节继续探索这3个问题的答案。</p>
<h2 id="内核模块（驱动）"><a href="#内核模块（驱动）" class="headerlink" title="内核模块（驱动）"></a>内核模块（驱动）</h2><p>STACK_TOP和PAGE_OFFSET 之间间隔的16M地址空间有什么用处呢？<br>参考文件”Documentation/arm/memory.txt”中的描述，动态加载的内核模块将被映射的到这个地址范围。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MODULES_VADDR	MODULES_END-1  Kernel module space</span><br><span class="line">                               Kernel modules inserted via insmod are</span><br><span class="line">                               placed here using dynamic mappings.</span><br></pre></td></tr></table></figure>

<p>对memory.txt的理解是否正确，并未通过编写一个内核模块来验证。</p>
<h2 id="CPU-向量页"><a href="#CPU-向量页" class="headerlink" title="CPU 向量页"></a>CPU 向量页</h2><p>在观察进程内存情况时，处于内核空间的[0xFFFF0000,0xFFFF1000]这一块地址空间主要用来做什么呢？<br>参考文件”Documentation/arm/memory.txt”中的描述。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ffff0000    ffff0fff    CPU vector page.</span><br><span class="line">                        The CPU vectors are mapped here if the</span><br><span class="line">                        CPU supports vector relocation (control</span><br><span class="line">                        register V bit.)</span><br></pre></td></tr></table></figure>
<p>在ARM架构下，这块空间主要用于存放异常处理相关代码，异常处理细节不在这里讨论。其实这块空间除了用于异常处理之外，还有几个特殊的地址。<br>在文件“Documentation/arm/kernel_user_helpers.txt”描述了几个特殊的地址：</p>
<ul>
<li>0xffff0fc0 存放了”__kuser_cmpxchg”的指令</li>
<li>0xffff0fa0 存放了“__kuser_memory_barrier”的指令</li>
</ul>
<p>在这里特别说明这两个地址，是因为开发模拟执行库时，某些库函数会直接跳转到这些地址开始执行，用于实现原子操作。</p>
<img src="/images/ida_sync_fetch_and_add_4.png" class="">

<h2 id="栈中的数据"><a href="#栈中的数据" class="headerlink" title="栈中的数据"></a>栈中的数据</h2><p>在主线程栈顶附近的数据到底是什么？<br>为了可以解析栈顶附近的数据，需要找到一个进程的入口在哪里，在Android系统中，每个进程的入口都在linker里，即内核完成进程资源准备后，将控制权移交给用户空间时，第一条执行的指令都是一样的：<br>代码文件：bionic/linker/arch/arm/begin.S</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ENTRY</span>(_start)</span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">r0</span>, <span class="built_in">sp</span></span><br><span class="line">  <span class="keyword">bl</span> __linker_init</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* linker init returns the _entry address in the main image */</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">pc</span>, <span class="built_in">r0</span></span><br><span class="line"><span class="symbol">END</span>(_start)</span><br></pre></td></tr></table></figure>

<p>函数“__linker_init”的代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> ElfW(Addr) __linker_init(<span class="keyword">void</span>* raw_args) &#123;</span><br><span class="line">  <span class="function">KernelArgumentBlock <span class="title">args</span><span class="params">(raw_args)</span></span>;</span><br><span class="line"></span><br><span class="line">  ElfW(Addr) linker_addr = args.getauxval(AT_BASE);</span><br><span class="line">  ElfW(Addr) entry_point = args.getauxval(AT_ENTRY);</span><br><span class="line">  ElfW(Ehdr)* elf_hdr = <span class="keyword">reinterpret_cast</span>&lt;ElfW(Ehdr)*&gt;(linker_addr);</span><br><span class="line">  ElfW(Phdr)* phdr = <span class="keyword">reinterpret_cast</span>&lt;ElfW(Phdr)*&gt;(linker_addr + elf_hdr-&gt;e_phoff);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>raw_args 就是栈的位置，解析栈数据应该在KernelArgumentBlock里。<br>类“KernelArgumentBlock”的代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KernelArgumentBlock</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  KernelArgumentBlock(<span class="keyword">void</span>* raw_args) &#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span>* args = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>*&gt;(raw_args);</span><br><span class="line">    argc = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(*args);</span><br><span class="line">    argv = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>**&gt;(args + <span class="number">1</span>);</span><br><span class="line">    envp = argv + argc + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip over all environment variable definitions to find aux vector.</span></span><br><span class="line">    <span class="comment">// The end of the environment block is marked by two NULL pointers.</span></span><br><span class="line">    <span class="keyword">char</span>** p = envp;</span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      ++p;</span><br><span class="line">    &#125;</span><br><span class="line">    ++p; <span class="comment">// Skip second NULL;</span></span><br><span class="line"></span><br><span class="line">    auxv = <span class="keyword">reinterpret_cast</span>&lt;ElfW(<span class="keyword">auxv_t</span>)*&gt;(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码逻辑，可总结出栈数据布局可能是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">position            content                     size (bytes)  comment</span><br><span class="line">  ------------------------------------------------------------------------</span><br><span class="line">stack pointer -&gt;  [ argc &#x3D; number of args ]     4      </span><br><span class="line">                  [ argv[0] (pointer) ]         4      </span><br><span class="line">                  [ argv[1] (pointer) ]         4      </span><br><span class="line">                  [ argv[..] (pointer) ]        4 * n  </span><br><span class="line">                  [ argv[n - 1] (pointer) ]     4      </span><br><span class="line">                  [ argv[n] (pointer) ]         4           &#x3D; NULL</span><br><span class="line"></span><br><span class="line">                  [ envp[0] (pointer) ]         4     </span><br><span class="line">                  [ envp[1] (pointer) ]         4      </span><br><span class="line">                  [ envp[..] (pointer) ]        4      </span><br><span class="line">                  [ envp[term] (pointer) ]      4           &#x3D; NULL</span><br><span class="line"></span><br><span class="line">                  [ auxv[0] (Elf32_auxv_t) ]    8      </span><br><span class="line">                  [ auxv[1] (Elf32_auxv_t) ]    8</span><br><span class="line">                  [ auxv[..] (Elf32_auxv_t) ]   8 </span><br><span class="line">                  [ auxv[term] (Elf32_auxv_t) ] 8           &#x3D; AT_NULL vector</span><br><span class="line"></span><br><span class="line">                  [ padding ]                   0 - 16     </span><br><span class="line"></span><br><span class="line">                  [ argument ASCIIZ strings ]   &gt;&#x3D; 0   </span><br><span class="line">                  [ environment ASCIIZ str. ]   &gt;&#x3D; 0   </span><br><span class="line"></span><br><span class="line">(0xbxxxxxxx)      [ end marker ]                4          &#x3D; NULL 结束</span><br><span class="line"></span><br><span class="line">(0xbx000000)       &lt; bottom of stack &gt;          0          (virtual)</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>接下来分析一个真实的进程，验证上述结论。进程主线程栈的范围是：be11e000-be91d000，当执行到__linker_init时，raw_args=0xBE91CB60。</p>
<img src="/images/main_thread_stack_BE91CB60.png" class="">

<p>按照顺序解析数据：<br>argc = 5<br>argv[0] = 0xBE91CC59 存储了字符串“ss.android.lotus.demo” 即进程名。<br>argv[1] = 0xBE91CC71 字符串为空<br>argv[2] = 0xBE91CC7A 字符串为空<br>argv[3] = 0xBE91CC86 字符串为空<br>argv[4] = 0xBE91CC8E 字符串为空<br>argv[5] = 0x00000000 NULL</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>继续分析envp结构，envp指向的数据：</p>
<img src="/images/main_thread_stack_BE91CCA0.png" class="">
<img src="/images/main_thread_stack_BE91CEC0.png" class="">
<p>envp[0] = 0xBE91CCA5 PATH=/sbin:/vendor/bin:/system/sbin:/system/bin:/system/xbin<br>envp[1] = 0xBE91CCE2 ANDROID_BOOTLOGO=1<br>envp[2] = 0xBE91CCF5 ANDROID_ROOT=/system<br>envp[3] = 0xBE91CD0A ANDROID_ASSETS=/system/app<br>envp[4] = 0xBE91CD25 ANDROID_DATA=/data<br>envp[5] = 0xBE91CD38 ANDROID_STORAGE=/storage<br>envp[6] = 0xBE91CD51 EXTERNAL_STORAGE=/sdcard<br>envp[7] = 0xBE91CD6A ASEC_MOUNTPOINT=/mnt/asec<br>envp[8] = 0xBE91CD84 BOOTCLASSPATH=/system/framework/core-libart.jar:/system/framework/conscrypt.jar:…<br>envp[9] = 0xBE91CF2C SYSTEMSERVERCLASSPATH=/system/framework/services.jar:…<br>envp[10] = 0xBE91CFAB ANDROID_PROPERTY_WORKSPACE=10,0<br>envp[11] = 0xBE91CFCB ANDROID_SOCKET_zygote=12<br>envp[12] = 0x00000000</p>
<h3 id="辅助向量表"><a href="#辅助向量表" class="headerlink" title="辅助向量表"></a>辅助向量表</h3><p>继续分析axuv接口，auxv结构体定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  __u32 a_type;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    __u32 a_val;</span><br><span class="line">  &#125; a_un;</span><br><span class="line">&#125; Elf32_auxv_t;</span><br></pre></td></tr></table></figure>
<p>每一项auxv占用8个字节。auxv 的type定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_NULL 0</span></span><br><span class="line"><span class="comment">/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_IGNORE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_EXECFD 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PHDR 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PHENT 4</span></span><br><span class="line"><span class="comment">/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PHNUM 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PAGESZ 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_BASE 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_FLAGS 8</span></span><br><span class="line"><span class="comment">/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_ENTRY 9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_NOTELF 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_UID 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_EUID 12</span></span><br><span class="line"><span class="comment">/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_GID 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_EGID 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_PLATFORM 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_HWCAP 16</span></span><br><span class="line"><span class="comment">/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_CLKTCK 17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_SECURE 23</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_BASE_PLATFORM 24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_RANDOM 25</span></span><br><span class="line"><span class="comment">/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_HWCAP2 26</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AT_EXECFN 31</span></span><br></pre></td></tr></table></figure>

<p>0xBE91CBB0 是auxv数据的开始地址。<br>auxv[0]=0x10(AT_HWCAP) 0x0007B0D7<br>auxv[1]=0x06(AT_PAGESZ) 0x00001000  页大小4KB<br>auxv[2]=0x11(AT_CLKTCK) 0x00000064<br>auxv[3]=0x03(AT_PHDR) 0xB6F79034 /system/bin/app_process32_xposed 的phdr地址<br>auxv[4]=0x04(AT_PHENT) 0x00000020 segment表每一项的大小<br>auxv[5]=0x05(AT_PHNUM) 0x00000009 segment表项数量<br>auxv[6]=0x07(AT_BASE) 0xB6F57000<br>auxv[7]=0x08(AT_FLAGS) 0x00000000<br>auxv[8]=0x09(AT_ENTRY) 0xB6F7DEE8<br>auxv[9]=0x0D(AT_GID) 0x00000000<br>auxv[10]=0x0E(AT_EGID) 0x00000000<br>auxv[11]=0x17(AT_SECURE) 0x00000000<br>auxv[12]=0x19(AT_RANDOM) 0xBE91CC45<br>auxv[13]=0x1F(AT_EXECFN) 0xBE91CFE4  “/system/bin/app_process”<br>auxv[14]=0x0F(AT_PLATFORM) 0xBE91CC55 “v71”<br>auxv[15]=0x00(AT_NULL) 0x00000000</p>
<p>AT_BASE=0xB6F57000表示linker在内存中的地址</p>
<img src="/images/lotus_memory_layout_auxv.png" class="">
<p>可以看出，“/system/bin/linker”在内存的开始地址正是0xB6F57000。<br>AT_ENTRY=0xB6F7DEE8表示app_process32_xposed的入口地址。根据app_process32_xposed的开始地址0xB6F79000，可以计算出入口的相对偏移：<br>RVA = 0xB6F7DEE8 - 0xB6F79000 = 0x4EE8<br>使用readelf可以解析出app_process32_xposed的入口正是0x4EE8。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ arm-linux-androideabi-readelf -h app_process32_xposed</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF32</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              DYN (Shared object file)</span></span><br><span class="line"><span class="string">  Machine:                           ARM</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x4ee8</span></span><br><span class="line"><span class="string">  Start of program headers:          52 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          91756 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x5000000, Version5 EABI</span></span><br><span class="line"><span class="string">  Size of this header:               52 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           32 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         9</span></span><br><span class="line"><span class="string">  Size of section headers:           40 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         32</span></span><br><span class="line"><span class="string">  Section header string table index: 29</span></span><br></pre></td></tr></table></figure>


<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文主要探索了ARM架构下Android系统中，进程的部分关键内存空间细节，目的是为了更加真实地模拟进程空间，提升模拟执行库的稳定性。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="http://androidxref.com/kernel_3.4">Linux Kernel 3.4</a></li>
<li><a target="_blank" rel="noopener" href="http://androidxref.com/6.0.1_r10">Android 6.0.1_r10</a></li>
</ul>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/Reverse-Engineering/">Reverse Engineering</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/android/">android</a>, <a href="/tags/arm/">arm</a>
  </div>

        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">Comments</h1>

  
      
<div id="gitalk-container"></div>   
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '15e82eced18a4f3699f5',
        clientSecret: '9159132c67a2722bbee0d59ff3026bb361bcd81c',
        repo: 'tatamobile_commnets',
        owner: 'vforkliu',
        admin: ["vforkliu"],
        id: '2022-02-09 17:10:09',
        title: 'Android进程内存布局：主线程的栈顶是多少？',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });
    gitalk.render('gitalk-container');
</script>
      
  
</section>



  <nav id="postnav">
    
    
      <p>上一篇 : <a href="/2022/02/10/Android-Application-Protector-Calculate-module-itself-load-base-address/" >如何快速计算Android进程模块自身的加载基地址？</a></p>
    
   
    
      <p>下一篇 : <a href="/2021/12/21/JNI-Function-Name-Override/" >JNI 方法注册和签名</a></p>
    
    
    <div class="clearfix"></div>
  </nav>
</div></div>
    <aside id="sidebar" class="alignright">
        
    <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="as_sitesearch" value="tatamobile.net">
  </form>
</div>


    
<div class="widget tag">
  <h3 class="title">Categories</h3>
  <ul class="entry">
  
    <li><a href="/categories/CMake/">CMake</a><small>1</small></li>
  
    <li><a href="/categories/Python/">Python</a><small>2</small></li>
  
    <li><a href="/categories/Qt/">Qt</a><small>1</small></li>
  
    <li><a href="/categories/Reverse-Engineering/">Reverse Engineering</a><small>5</small></li>
  
  </ul>
</div>


    
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/C/">C++</a><small>1</small></li>
  
    <li><a href="/tags/CMake/">CMake</a><small>1</small></li>
  
    <li><a href="/tags/Decorator/">Decorator</a><small>1</small></li>
  
    <li><a href="/tags/Metaclass/">Metaclass</a><small>1</small></li>
  
    <li><a href="/tags/Python/">Python</a><small>2</small></li>
  
    <li><a href="/tags/Qt/">Qt</a><small>1</small></li>
  
    <li><a href="/tags/android/">android</a><small>3</small></li>
  
    <li><a href="/tags/arm/">arm</a><small>4</small></li>
  
    <li><a href="/tags/elf/">elf</a><small>1</small></li>
  
    <li><a href="/tags/java/">java</a><small>1</small></li>
  
    <li><a href="/tags/jni/">jni</a><small>1</small></li>
  
    <li><a href="/tags/markdown/">markdown</a><small>1</small></li>
  
    <li><a href="/tags/unicorn/">unicorn</a><small>1</small></li>
  
  </ul>
</div>


        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6011041061943855" crossorigin="anonymous"></script>
        <!-- 侧边栏广告 -->
        <ins class="adsbygoogle"
            style="display:block"
            data-ad-client="ca-pub-6011041061943855"
            data-ad-slot="2644505017"
            data-ad-format="auto"
            data-full-width-responsive="true"></ins>
        <script>
            (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
    </aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2021-2024 TATAMOBILE
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
