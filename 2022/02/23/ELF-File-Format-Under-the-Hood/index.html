<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>重学ELF文件格式 | TATAMOBILE</title>
  <meta name="author" content="TATAMOBILE">
  
  <meta name="description" content="user growth tech">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="重学ELF文件格式"/>
  <meta property="og:site_name" content="TATAMOBILE"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script><![endif]-->
  
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-FXZ3M3DJK6"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-FXZ3M3DJK6');
</script>


  
<!-- Google Adsense -->
<!-- <script data-ad-client="ca-pub-6011041061943855" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> -->

  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">TATAMOBILE</a></h1>
  <h2><a href="/">安卓源码分析</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-ELF-File-Format-Under-the-Hood" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2022-02-23T12:52:22.000Z"><a href="/2022/02/23/ELF-File-Format-Under-the-Hood/">2022-02-23</a></time>
        
  
    <h1 class="p-name title" itemprop="headline name">重学ELF文件格式</h1>
  

      
    </header>
    <div class="e-content entry" itemprop="articleBody">
        
      
        <!-- Table of Contents -->
        
        <h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>ELF文件格式的讨论已经存在非常多的文章，这里试图从另一个角度来讨论如何学习ELF文件格式。OAID SDK已经更新到1.0.30了，发现代码保护方式变化了，采用了自实现Linker方式来保护代码，libmsaoaidsec.so 就是负责释放真实的so。但本文不讨论释放和自加载过程，主要讨论从内存中dump真实代码到文件后，如何修复这个ELF文件，达到学习ELF文件格式的目的。放一张ELF文件结构图，有个整体印象：</p>
<img src="/images/elf_view.png" class="">

<h2 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h2><p>可以从链接视图和内存视图两个角度来观察ELF文件格式，一般的ELF文件修复工具都是从内存视图解析相关信息后重构出链接视图。但从OAID SDK 内存中dump出来的文件，程序头表(PHDR)已经被抹除了。</p>
<img src="/images/sodump_oaid_ehdr.png" class="">

<p>从图中可知，ELF文件头被”F1F1”覆盖了，就不能解析出PHDR，一般的修复工具就失效了。遇到这种情况，该如何修复呢？逆向工程有一个指导原则：“正反结合”。可以这样假设：这个dump出来的ELF文件和标准的ELF文件相比，只有ELF文件头部有改变，其他地方应该和标准的ELF文件格式一样。可以自己编译一个标准的ELF文件一一对比布局，就可以修复。从上图还可以看出，OAID SDK应该是采用NDK r16 编译的，为了消除编译器差异，我们也用相同版本的NDK编译出一个标准的ELF文件。标准ELF文件的文件头如下：</p>
<img src="/images/elf_ndk_r16b_ehdr.png" class="">

<p>通过对比可知，主要差异确实就是程序头部表（Program Header Table）。</p>
<h2 id="重建"><a href="#重建" class="headerlink" title="重建"></a>重建</h2><h3 id="ELF文件头"><a href="#ELF文件头" class="headerlink" title="ELF文件头"></a>ELF文件头</h3><p>通过观察可知，dump文件的EHDR是完整的，可以解析，解析结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; data length: 0x0009d000</span><br><span class="line">ident:7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">&gt;&gt;&gt; parse elf header ...</span><br><span class="line">Class: ELFCLASS32</span><br><span class="line">Type: ET_DYN</span><br><span class="line">Machine: EM_ARM</span><br><span class="line">Version: EV_CURRENT</span><br><span class="line">Start of section headers: 0x0</span><br><span class="line">Entry point address: 0x9b1ec</span><br><span class="line">Start of program headers: 0x34</span><br><span class="line">Start of section headers: 0x9b1ec</span><br><span class="line">Flags: 0x5000200</span><br><span class="line">Size of this header: 0x34</span><br><span class="line">Size of program headers: 32</span><br><span class="line">Number of program headers: 8</span><br><span class="line">Size of section headers: 40</span><br><span class="line">Number of section headers: 27</span><br><span class="line">Section header string table index: 26</span><br><span class="line">+++ ph offset: 0x34 - 0x134</span><br><span class="line">+++ sh offset: 0x9b1ec - 0x9b624</span><br></pre></td></tr></table></figure>

<p>dump ELF文件有8个program header和26个section header,标准ELF文件有8个program header和27个section header。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ arm-linux-androideabi-readelf -h libarmelfformat.so</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF32</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              DYN (Shared object file)</span></span><br><span class="line"><span class="string">  Machine:                           ARM</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x0</span></span><br><span class="line"><span class="string">  Start of program headers:          52 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          103040 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x5000200, Version5 EABI, soft-float ABI</span></span><br><span class="line"><span class="string">  Size of this header:               52 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           32 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         8</span></span><br><span class="line"><span class="string">  Size of section headers:           40 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         28</span></span><br><span class="line"><span class="string">  Section header string table index: 27</span></span><br></pre></td></tr></table></figure>

<h3 id="初探ELF段表-Segment-Header-Table"><a href="#初探ELF段表-Segment-Header-Table" class="headerlink" title="初探ELF段表(Segment Header Table)"></a>初探ELF段表(Segment Header Table)</h3><p>观察标准ELF文件段表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-androideabi-readelf -l libarmelfformat.so</span><br><span class="line">Elf file <span class="built_in">type</span> is DYN (Shared object file)</span><br><span class="line">Entry point 0x0</span><br><span class="line">There are 8 program headers, starting at offset 52</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span><br><span class="line">  PHDR           0x000034 0x00000034 0x00000034 0x00100 0x00100 R   0x4</span><br><span class="line">  LOAD           0x000000 0x00000000 0x00000000 0x17b7c 0x17b7c R E 0x1000</span><br><span class="line">  LOAD           0x017fc0 0x00018fc0 0x00018fc0 0x010d4 0x06014 RW  0x1000</span><br><span class="line">  DYNAMIC        0x018c1c 0x00019c1c 0x00019c1c 0x00120 0x00120 RW  0x4</span><br><span class="line">  NOTE           0x000134 0x00000134 0x00000134 0x000bc 0x000bc R   0x4</span><br><span class="line">  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x10</span><br><span class="line">  EXIDX          0x015580 0x00015580 0x00015580 0x00bb0 0x00bb0 R   0x4</span><br><span class="line">  GNU_RELRO      0x017fc0 0x00018fc0 0x00018fc0 0x01040 0x01040 RW  0x8</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00</span><br><span class="line">   01     .note.android.ident .note.gnu.build-id .dynsym .dynstr .<span class="built_in">hash</span> .gnu.version .gnu.version_d .gnu.version_r .rel.dyn .rel.plt .plt .text .ARM.extab .ARM.exidx .rodata</span><br><span class="line">   02     .data.rel.ro.local .fini_array .data.rel.ro .init_array .dynamic .got .data .bss</span><br><span class="line">   03     .dynamic</span><br><span class="line">   04     .note.android.ident .note.gnu.build-id</span><br><span class="line">   05</span><br><span class="line">   06     .ARM.exidx</span><br><span class="line">   07     .data.rel.ro.local .fini_array .data.rel.ro .init_array .dynamic .got</span><br></pre></td></tr></table></figure>
<p>重建ELF文件的过程就是要分析出每个段(Segment)和节(Section)的开始位置和大小。从标准ELF文件分析结果，可以确定两个段的开始位置和大小：PHDR和NOTE。对于其它段全部先暂时全部填充0。为了能让IDA等工具可以加载分析，需要生成一个LOAD段，暂时将开始位置设为0，大小为整个文件的大小。</p>
<p>段PHDR 开始位置：0x34，大小：0x100，恰好就是整个段表。<br>段NOTE 开始位置：0x134,大小：0xbc，来看下是什么内容：</p>
<img src="/images/sodump_oaid_segment_note.png" class="">

<p>看起来像是在描述编译器的信息，比如NDK版本号和GCC版本号等。<br>到目前为止，已经分析出两个段的信息，经过与标准ELF文件比对，应该是正确的。</p>
<h3 id="初探ELF节表-Section-Header-Table"><a href="#初探ELF节表-Section-Header-Table" class="headerlink" title="初探ELF节表(Section Header Table)"></a>初探ELF节表(Section Header Table)</h3><p>观察标准ELF文件节表</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-androideabi-readelf -S libarmelfformat.so</span><br><span class="line">There are 28 section headers, starting at offset 0x19280:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .note.android.ide NOTE            00000134 000134 000098 00   A  0   0  4</span><br><span class="line">  [ 2] .note.gnu.build-i NOTE            000001cc 0001cc 000024 00   A  0   0  4</span><br><span class="line">  [ 3] .dynsym           DYNSYM          000001f0 0001f0 000b20 10   A  4   1  4</span><br><span class="line">  [ 4] .dynstr           STRTAB          00000d10 000d10 001496 00   A  0   0  1</span><br><span class="line">  [ 5] .<span class="built_in">hash</span>             HASH            000021a8 0021a8 0004dc 04   A  3   0  4</span><br><span class="line">  [ 6] .gnu.version      VERSYM          00002684 002684 000164 02   A  3   0  2</span><br><span class="line">  [ 7] .gnu.version_d    VERDEF          000027e8 0027e8 00001c 00   A  4   1  4</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         00002804 002804 000020 00   A  4   1  4</span><br><span class="line">  [ 9] .rel.dyn          REL             00002824 002824 001118 08   A  3   0  4</span><br><span class="line">  [10] .rel.plt          REL             0000393c 00393c 000348 08  AI  3  21  4</span><br><span class="line">  [11] .plt              PROGBITS        00003c84 003c84 000500 00  AX  0   0  4</span><br><span class="line">  [12] .text             PROGBITS        00004184 004184 010d18 00  AX  0   0  4</span><br><span class="line">  [13] .ARM.extab        PROGBITS        00014e9c 014e9c 0006e4 00   A  0   0  4</span><br><span class="line">  [14] .ARM.exidx        ARM_EXIDX       00015580 015580 000bb0 08  AL 12   0  4</span><br><span class="line">  [15] .rodata           PROGBITS        00016130 016130 001a4c 00   A  0   0  4</span><br><span class="line">  [16] .data.rel.ro.loca PROGBITS        00018fc0 017fc0 0007b8 00  WA  0   0  8</span><br><span class="line">  [17] .fini_array       FINI_ARRAY      00019778 018778 000008 04  WA  0   0  4</span><br><span class="line">  [18] .data.rel.ro      PROGBITS        00019780 018780 00048c 00  WA  0   0  8</span><br><span class="line">  [19] .init_array       INIT_ARRAY      00019c0c 018c0c 000010 04  WA  0   0  4</span><br><span class="line">  [20] .dynamic          DYNAMIC         00019c1c 018c1c 000120 08  WA  4   0  4</span><br><span class="line">  [21] .got              PROGBITS        00019d40 018d40 0002c0 00  WA  0   0  4</span><br><span class="line">  [22] .data             PROGBITS        0001a000 019000 000094 00  WA  0   0  4</span><br><span class="line">  [23] .bss              NOBITS          0001a098 019094 004f3c 00  WA  0   0  8</span><br><span class="line">  [24] .comment          PROGBITS        00000000 019094 000065 01  MS  0   0  1</span><br><span class="line">  [25] .note.gnu.gold-ve NOTE            00000000 0190fc 00001c 00      0   0  4</span><br><span class="line">  [26] .ARM.attributes   ARM_ATTRIBUTES  00000000 019118 00003d 00      0   0  1</span><br><span class="line">  [27] .shstrtab         STRTAB          00000000 019155 00012a 00      0   0  1</span><br></pre></td></tr></table></figure>

<p>节.note.android.ident和.note.gnu.build-id的内容和段NOTE是一致的。紧挨着的是节.dynsym和.dynstr。可以确定节.dynsym的开始位置就是0x1f0。但如何确定.dynsym的结束位置呢？可以使用节.dynstr开头内容的特征区分，标准ELF文件节.dynstr开头的内容：</p>
<img src="/images/elf_ndk_r16b_dynstr.png" class="">

<p>从上图可知，节.dynstr开头的字符串是“.__cxa_finalize”，尝试在dump文件里顺序查找，看是否有这样的特征：</p>
<img src="/images/sodump_oaid_dynstr.png" class="">

<p>这样就可以初步确定节.dynsym的开始和结束位置：0x01F0 ~ 0x31D0。节.dynstr的开始位置：0x31D0，那.dynstr的结束位置如何确定呢？ </p>
<img src="/images/sodump_oaid_dynstr_end.png" class="">

<p>从上图观察，节.dynstr的结束位置还是非常好确定的，初步认为就是：0xA9B4。接下来计算节.hash的大小，根据.hash的结构计算：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(nbuckets + nchains + 1 + 1) * 4 = (0x209 + 0x2FE + 1 + 1) * 4 = 0x1424</span><br></pre></td></tr></table></figure>
<p>紧接着，节.gnu.version的开始位置是：0xA9B4 + 0x1424 = 0xBDD8。<br>小结：到目前为止，我们已经分析出5个节的开始位置和结束位置</p>
<ul>
<li>.note.android.ident : 0x134 ~ 0x1CC</li>
<li>.note.gnu.build-id : 0x1CC ~ 0x1F0</li>
<li>.dynsym : 0x01F0 ~ 0x31D0</li>
<li>.dynstr: 0x31D0 ~ 0xA9B4</li>
<li>.hash: 0xA9B4 ~ 0xBDD8</li>
</ul>
<p>接下来分析节.plt(Procedure Linkage Table)，带版本的符号相关节(.gnu.version)暂不分析。</p>
<h3 id="分析节-PLT"><a href="#分析节-PLT" class="headerlink" title="分析节.PLT"></a>分析节.PLT</h3><p>通过观察节.plt和节.text是紧挨着的，且开始位置有明显的特征。观察节.plt开始位置和结束位置的反汇编代码，<br>开始位置：</p>
<img src="/images/sodump_oaid_plt_start.png" class="">
<p>结束位置：</p>
<img src="/images/sodump_oaid_plt_end.png" class="">

<p>节.plt开始位置是固定16字节的一个函数sub_D438，然后接着就是一组类似sub_D44C这样的函数，直到结束。因此，节.plt的开始位置和结束位置是：0xD438 ~ 0xD920。</p>
<p>从节.plt节的信息还可以计算出节.rel.plt的大小，计算方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(0xD920 - 0xD438 - 0x14) / 0xC = 0x67</span><br></pre></td></tr></table></figure>
<p>0x67 是节.rel.plt中重定位的数量，上述公式中的0x14是函数sub_D438的大小，0xC是每个桩函数如sub_D44C的大小。<br>由于节.rel.plt与节.plt相邻，因此节.rel.plt的结束位置：0xD438，重定位每项大小为8，个数为0x67，大小为0x338。节.rel.plt的开始位置和结束位置为：0xD100 ~ 0xD438。那么节.rel.dyn的结束位置为：0xD100。那如何确定节.rel.dyn的开始位置呢？还是根据特征。观察标准ELF文件节.rel.dyn开始位置的内容：</p>
<img src="/images/elf_ndk_r16b_rel_dyn_start.png" class="">
<p>可以看到有大量的0x17（0x17 就是 R_ARM_RELATIVE），由此可以找到dump文件中节.rel.dyn的开始位置：</p>
<img src="/images/sodump_oaid_rel_dyn_start.png" class="">
<p>可初步推断节.rel.dyn的开始位置是0xC430，即节.rel.dyn的开始和结束位置为：0xC430 ~ 0xD100。</p>
<p>继续观察前面提到的函数sub_D438中的一行汇编代码：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LDR</span>             <span class="built_in">LR</span>, =(dword_9BE58 - <span class="number">0xD448</span>)</span><br></pre></td></tr></table></figure>
<p>dword_9BE58就是常说的“_GLOBAL_OFFSET_TABLE_”，即0x9BE58在节.got范围内。从0x9BE58向前和向后观察，可以初步推断节.got的开始和结束位置。<br>开始位置：</p>
<img src="/images/sodump_oaid_got_start.png" class="">
<p>结束位置：</p>
<img src="/images/sodump_oaid_got_end.png" class="">

<p>小结：到目前为止，初步分析出4个节的开始和结束位置：</p>
<ul>
<li>.rel.dyn : 0xC430 ~ 0xD100</li>
<li>.rel.plt : 0xD100 ~ 0xD438</li>
<li>.plt : 0xD438 ~ 0xD920</li>
<li>.got : 0x9BDCC ~ 0x9C000</li>
</ul>
<h3 id="带版本信息的符号"><a href="#带版本信息的符号" class="headerlink" title="带版本信息的符号"></a>带版本信息的符号</h3><p>与版本符号相关的节一般是3个：.gnu.version，.gnu.version_d和.gnu.version_r。根据前文的分析可知，这3个节的开始和结束位置是：0xBDD8 ~ 0xC430。如何来划分这3个节各自的开始和结束位置呢？主要通过相关节的作用来分析。参考<a target="_blank" rel="noopener" href="https://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-PDA/LSB-PDA.junk/symversion.html">Symbol Versioning</a>。</p>
<h4 id="gnu-version"><a href="#gnu-version" class="headerlink" title=".gnu.version"></a>.gnu.version</h4><p>来看一段节.gnu.version的描述：</p>
<blockquote>
<p>The special section .gnu.version which has a section type of SHT_GNU_versym shall contain the Symbol Version Table. This section shall have the same number of entries as the Dynamic Symbol Table in the .dynsym section.</p>
</blockquote>
<p>翻译：节.gnu.version与节.dynsym的项数相同。</p>
<blockquote>
<p>The .gnu.version section shall contain an array of elements of type Elfxx_Half. Each entry specifies the version defined for or required by the corresponding symbol in the Dynamic Symbol Table.</p>
</blockquote>
<p>翻译：节.gnu.version每一项的大小是2字节。</p>
<p>节.dynsym的开始和结束位置是：0x01F0 ~ 0x31D0。项数是：(0x31D0 - 0x01F0) / 0x10 = 0x2FE，因此，节.gnu.version的大小是：0x2FE * 2 = 0x5FC，开始和结束位置是：0xBDD8 ~ 0xC3D4</p>
<h4 id="gnu-version-d"><a href="#gnu-version-d" class="headerlink" title=".gnu.version_d"></a>.gnu.version_d</h4><p>来看一段.gnu.version_d的描述：</p>
<blockquote>
<p>The special section .gnu.version_d which has a section type of SHT_GNU_verdef shall contain symbol version definitions. The number of entries in this section shall be contained in the DT_VERDEFNUM entry of the Dynamic Section .dynamic. The sh_link member of the section header (see figure 4-8 in the System V ABI) shall point to the section that contains the strings referenced by this section.</p>
</blockquote>
<p>翻译：.gnu.version_d的sh_link一般指向节.dynstr，且与节.dynamic中的某一项DT_VERDEFNUM有关。</p>
<blockquote>
<p>The section shall contain an array of Elfxx_Verdef structures,optionally followed by an array of Elfxx_Verdaux structures</p>
</blockquote>
<p>翻译：节.gnu.version_d 是一个数组，每一项是结构Elfxx_Verdef，可能会跟Elfxx_Verdaux。</p>
<p>结构体Elfxx_Verdef定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Elfxx_Half    vd_version;</span><br><span class="line">	Elfxx_Half    vd_flags;</span><br><span class="line">	Elfxx_Half    vd_ndx;</span><br><span class="line">	Elfxx_Half    vd_cnt;</span><br><span class="line">	Elfxx_Word    vd_hash;</span><br><span class="line">	Elfxx_Word    vd_aux;</span><br><span class="line">	Elfxx_Word    vd_next;</span><br><span class="line">&#125; Elfxx_Verdef;</span><br></pre></td></tr></table></figure>
<p>结构体Elfxx_Verdaux定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Elfxx_Word    vda_name;</span><br><span class="line">	Elfxx_Word    vda_next;</span><br><span class="line">&#125; Elfxx_Verdaux;</span><br></pre></td></tr></table></figure>
<p>每个成员的含义，用修复好的实际例子解释，一般的so节.gnu.version_d只有一项：</p>
<img src="/images/sodump_oaid_gnu_version_d.png" class="">

<ul>
<li>vd_cnt:与之关联的verdaux有几个，这里是1个。</li>
<li>vd_aux: verdaux偏移，这里是0x14。</li>
<li>vd_next: 下一个verdef偏移。这里是0，表示结束。</li>
<li>vda_name: 在.dynstr中的偏移。值为0x1D。</li>
<li>vda_next: 下一个verdaux入口位置。值为0，表示结束。</li>
</ul>
<h4 id="gnu-version-r"><a href="#gnu-version-r" class="headerlink" title=".gnu.version_r"></a>.gnu.version_r</h4><p>来看一段关于节.gnu.version_r的描述：</p>
<blockquote>
<p>The special section .gnu.version_r which has a section type of SHT_GNU_verneed shall contain required symbol version definitions. The number of entries in this section shall be contained in the DT_VERNEEDNUM entry of the Dynamic Section .dynamic. The sh_link member of the section header (see figure 4-8 in System V ABI) shall point to the section that contains the strings referenced by this section.</p>
</blockquote>
<p>翻译：.gnu.version_r的sh_link一般指向节.dynstr，且与节.dynamic中的某一项DT_VERNEEDNUM有关。</p>
<blockquote>
<p>The section shall contain an array of Elfxx_Verneed structures, as described in Figure 2-3, optionally followed by an array of Elfxx_Vernaux structures, as defined in Figure 2-4.</p>
</blockquote>
<p>翻译：节.gnu.version_r 是一个数组，每一项是结构Elfxx_Verneed，可能会跟Elfxx_Vernaux。</p>
<p>结构体Elfxx_Verneed的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Elfxx_Half    vn_version;</span><br><span class="line">	Elfxx_Half    vn_cnt;</span><br><span class="line">	Elfxx_Word    vn_file;</span><br><span class="line">	Elfxx_Word    vn_aux;</span><br><span class="line">	Elfxx_Word    vn_next;</span><br><span class="line">&#125; Elfxx_Verneed;</span><br></pre></td></tr></table></figure>

<p>结构体Elfxx_Vernaux的定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Elfxx_Word    vna_hash;</span><br><span class="line">	Elfxx_Half    vna_flags;</span><br><span class="line">	Elfxx_Half    vna_other;</span><br><span class="line">	Elfxx_Word    vna_name;</span><br><span class="line">	Elfxx_Word    vna_next;</span><br><span class="line">&#125; Elfxx_Vernaux;</span><br></pre></td></tr></table></figure>
<p>每个成员的含义，用修复好的实际例子解释:</p>
<img src="/images/sodump_oaid_gnu_version_r.png" class="">
<ul>
<li>vn_file : 在节.dynstr的偏移 。</li>
<li>vn_aux :  与这个verneed关联的vernaux入口偏移。</li>
<li>vn_next : 下一个verneed入口的偏移。</li>
<li>vna_name : 在节.dynstr的偏移。</li>
<li>vna_next : 下一个vernaux入口的偏移。</li>
</ul>
<p>本文不关注“版本符号”的用途，只关注节的边界，所以只选择了解释与偏移、大小等相关成员解释。</p>
<p>小结：本节分析出3个节的开始和结束位置：</p>
<ul>
<li>.gnu.version : 0xBDD8 ~ 0xC3D4</li>
<li>.gnu.version_d : 0xC3D4 ~ 0xC3F0</li>
<li>.gnu_version_r : 0xC3F0 ~ 0xC430</li>
</ul>
<h3 id="节-ARM-exidx和-ARM-extab"><a href="#节-ARM-exidx和-ARM-extab" class="headerlink" title="节.ARM.exidx和.ARM.extab"></a>节.ARM.exidx和.ARM.extab</h3><p>节.ARM.exidx和.ARM.extab是ARM架构体系下专门用于异常处理：发生异常时，借助这两个节的信息还原出调用栈，此方法与传统的基于EBP恢复调用栈区别很大，如何恢复调用栈，不在本文讨论，这里主要借助这两个节的特殊信息来确定其他节的边界，比如节.text。</p>
<p>节.text,.ARM.extab,.ARM.exidx和.rodata 4个节相邻，从前面分析可知，节.text开始位置是：0xD920。那节.ARM.exidx如何确定开始和结束位置呢？其实没什么办法直接分析出来，不过可以先看看节.rodata的开始位置在哪里？观察下图：</p>
<img src="/images/sodump_oaid_rodata_start.png" class="">
<p>初步判断0x93620，因为0x93621一定在节.rodata里，根据对齐原则，可认为0x93620就是节.rodata的开始位置，也是节.ARM.exidx的结束位置。先直接给出结论，可以使用如下脚本直接分析出节.ARM.exidx和.ARM.extab的边界：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="keyword">from</span> elftools.elf.elffile <span class="keyword">import</span> ELFFile</span><br><span class="line"><span class="keyword">from</span> elftools.elf.structs <span class="keyword">import</span> ELFStructs</span><br><span class="line"><span class="keyword">from</span> elftools.ehabi.ehabiinfo <span class="keyword">import</span> EHABIInfo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryELFFile</span>(<span class="params">ELFFile</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;精简过的 ELFFile，去除里面多余的功能&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, stream</span>):</span></span><br><span class="line">        self.stream = stream</span><br><span class="line">        self._identify_file()</span><br><span class="line">        self.structs = ELFStructs(</span><br><span class="line">            little_endian=self.little_endian,</span><br><span class="line">            elfclass=self.elfclass)</span><br><span class="line"></span><br><span class="line">        self.structs.create_basic_structs()</span><br><span class="line">        self.header = self._parse_elf_header()</span><br><span class="line">        self.structs.e_type = self[<span class="string">&#x27;e_type&#x27;</span>]</span><br><span class="line">        self.structs.e_machine = self[<span class="string">&#x27;e_machine&#x27;</span>]</span><br><span class="line">        self.structs.e_ident_osabi = self[<span class="string">&#x27;e_ident&#x27;</span>][<span class="string">&#x27;EI_OSABI&#x27;</span>]</span><br><span class="line">        self.structs._create_phdr()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FakeSection</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;因为无法从内存中恢复完整的 Section，只能手动创建虚假的 Section，填充关键数据&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, stream, offset, size</span>):</span></span><br><span class="line">        self.stream = stream</span><br><span class="line">        self.offset = offset</span><br><span class="line">        self.size = size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">&#x27;sh_offset&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> self.offset</span><br><span class="line">        <span class="keyword">elif</span> item == <span class="string">&#x27;sh_size&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> self.size</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">特征码:80A8B0B0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    filename = <span class="string">&quot;./data/libdump_oaid_0x9ad23000_0x0009d000.bin&quot;</span></span><br><span class="line">    print(filename)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">        stream = BytesIO(data)</span><br><span class="line">        elf = MemoryELFFile(stream)</span><br><span class="line">        print(elf)</span><br><span class="line"></span><br><span class="line">        exidx_offset = <span class="number">0x917c8</span></span><br><span class="line">        exidx_size = <span class="number">0x93620</span> - exidx_offset</span><br><span class="line">        ehabi_info = EHABIInfo(FakeSection(stream, exidx_offset, exidx_size), elf.little_endian)</span><br><span class="line">        print(<span class="string">&quot;exentry count: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(ehabi_info.num_entry()))</span><br><span class="line">        eh_table_offset_max = <span class="number">0</span></span><br><span class="line">        eh_table_offset_min = <span class="number">0xFFFFFFFF</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ehabi_info.num_entry()):</span><br><span class="line">            entry = ehabi_info.get_entry(i)</span><br><span class="line">            print(entry)</span><br><span class="line">            eh_table_offset = entry.eh_table_offset</span><br><span class="line">            <span class="keyword">if</span> eh_table_offset <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> eh_table_offset &lt; eh_table_offset_min:</span><br><span class="line">                eh_table_offset_min = eh_table_offset</span><br><span class="line">            <span class="keyword">if</span> eh_table_offset &gt; eh_table_offset_max:</span><br><span class="line">                eh_table_offset_max = eh_table_offset</span><br><span class="line">    print(<span class="string">&quot;extab:0x&#123;:x&#125;-0x&#123;:x&#125;&quot;</span>.<span class="built_in">format</span>(eh_table_offset_min, eh_table_offset_max))</span><br><span class="line">    print(<span class="string">&quot;success.&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行脚本，结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python3 parser_arm_exidx.py</span><br><span class="line">...</span><br><span class="line">extab:0x8dc50-0x917bc</span><br><span class="line">success.</span><br></pre></td></tr></table></figure>
<p>由此可确定三个节的开始和结束位置：</p>
<ul>
<li>.text : 0xD920 ~ 0x8dc50</li>
<li>.ARM.extab : 0x8dc50-0x917bc</li>
<li>.ARM.exidx : 0x917bc-0x93620</li>
</ul>
<p>现在，来解释一下上述脚本的关键点</p>
<ul>
<li>0x93620 是我们初步分析出的.rodata的开始位置也是.ARM.exidx的结束位置，经过解析0x93620前的几个字节是否合法，就进一步确定了0x93620就是节.ARM.exidx的结束位置。</li>
<li>0x917c8 代码中的这个数值是节.ARM.exidx的开始位置，是怎么分析出来的？没有什么好办法，就是从0x93620一直向前试，知道脚本不能正常解析，就找到了开始位置。每次向前移动8个字节，.ARM.exidx每一项的大小是8字节。</li>
<li>由于.ARM.extab是.ARM.exidx的辅助信息，完全可借助每一项信息分析出.ARM.extab的开始位置。观察一下解析结果就明白了：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;EHABIEntry function_offset=0xd930, personality=1, eh_table_offset=0x8dda0, bytecode=[151, 65, 132, 11, 176, 176]&gt;</span><br><span class="line">&lt;CannotUnwindEHABIEntry function_offset=0xd9cc&gt;</span><br><span class="line">&lt;EHABIEntry function_offset=0xd9f8, personality=1, eh_table_offset=0x8dc50, bytecode=[151, 65, 132, 13, 176, 176]&gt;</span><br><span class="line">&lt;EHABIEntry function_offset=0xda34, personality=1, eh_table_offset=0x8dc5c, bytecode=[151, 65, 132, 13, 176, 176]&gt;</span><br><span class="line">&lt;EHABIEntry function_offset=0xda70, personality=1, eh_table_offset=0x8dc68, bytecode=[151, 65, 132, 13, 176, 176]&gt;</span><br><span class="line">&lt;EHABIEntry function_offset=0xdaac, personality=1, eh_table_offset=0x8dc74, bytecode=[151, 67, 128, 128, 171, 176]&gt;</span><br><span class="line">&lt;EHABIEntry function_offset=0xdb24, personality=1, eh_table_offset=0x8dc80, bytecode=[151, 70, 128, 240, 171, 176]&gt;</span><br></pre></td></tr></table></figure>
需要深入学习.ARM.exidx的内容，也可通过readelf查看：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -u liboaid.so</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="节-init-array和-fini-array"><a href="#节-init-array和-fini-array" class="headerlink" title="节.init_array和.fini_array"></a>节.init_array和.fini_array</h3><p>这两个节的位置比较好确定，与.rodata相邻，这里直接给出结论：</p>
<ul>
<li>.fini_array : 0x9B5C4 ~ 0x9B5CC</li>
<li>.init_array : 0x9B5CC ~ 0x9B5D4</li>
</ul>
<p>那如何区分这两个节谁在前呢？可根据数组中函数确定。先看两个节的内容：</p>
<img src="/images/sodump_oaid_fini_array.png" class="">
<p>继续考察函数sub_D920：</p>
<img src="/images/sodump_oaid_func_cxa_finalize.png" class="">

<p>调用__cxa_finalize的函数只可能在节.fini_array里，而且一般的so里都有这个函数，因此当不能确定.fini_array的位置时，可以根据谁引用了函数sub_D920来确定节.fini_array的大致位置。</p>
<h3 id="节-dynamic"><a href="#节-dynamic" class="headerlink" title="节.dynamic"></a>节.dynamic</h3><p>这个节非常重要，大部分修复工具也是根据这个节的内容分析出其他节的范围，但非常可惜，本文修复的目标文件把这个节的内容抹除了。节.dynamic一般在节.got的前面，看一下抹除后的内容：</p>
<img src="/images/sodump_oaid_dynamic_pre_fix.png" class="">
<p>这里根据前面的分析结果，重建节.dynamic，重建脚本片段</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rebuild_dynamic</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="comment"># 重建dynamic</span></span><br><span class="line">      print(<span class="string">&quot;&gt;&gt;&gt; rebuild dynamic ...&quot;</span>)</span><br><span class="line">      self.dyns = <span class="built_in">list</span>()</span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_PLTGOT&#x27;</span>],d_val=<span class="number">0x9BDCC</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_PLTRELSZ&#x27;</span>],d_val=<span class="number">824</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_JMPREL&#x27;</span>],d_val=<span class="number">0xD100</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_PLTREL&#x27;</span>],d_val=<span class="number">0x11</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_REL&#x27;</span>],d_val=<span class="number">0xc430</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_RELSZ&#x27;</span>],d_val=<span class="number">0xcd0</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_RELENT&#x27;</span>],d_val=<span class="number">8</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_RELCOUNT&#x27;</span>],d_val=<span class="number">96</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_SYMTAB&#x27;</span>],d_val=<span class="number">0x1f0</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_SYMENT&#x27;</span>],d_val=<span class="number">0x10</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_STRTAB&#x27;</span>],d_val=<span class="number">0x31D0</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_STRSZ&#x27;</span>],d_val=<span class="number">0x77E4</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_HASH&#x27;</span>],d_val=<span class="number">0xa9b4</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_NEEDED&#x27;</span>],d_val=<span class="number">0xa9a7</span>-<span class="number">0x31D0</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_NEEDED&#x27;</span>],d_val=<span class="number">0xa99f</span>-<span class="number">0x31D0</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_NEEDED&#x27;</span>],d_val=<span class="number">0xa995</span>-<span class="number">0x31D0</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_NEEDED&#x27;</span>],d_val=<span class="number">0x5e45</span>-<span class="number">0x31D0</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_NEEDED&#x27;</span>],d_val=<span class="number">0x15</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_SONAME&#x27;</span>],d_val=<span class="number">0x1d</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_FINI_ARRAY&#x27;</span>],d_val=<span class="number">0x9B5C4</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_FINI_ARRAYSZ&#x27;</span>],d_val=<span class="number">8</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_INIT_ARRAY&#x27;</span>],d_val=<span class="number">0x9B5CC</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_INIT_ARRAYSZ&#x27;</span>],d_val=<span class="number">8</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_FLAGS&#x27;</span>],d_val=<span class="number">8</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_FLAGS_1&#x27;</span>],d_val=<span class="number">1</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_VERSYM&#x27;</span>],d_val=<span class="number">0xbdd8</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_VERDEF&#x27;</span>],d_val=<span class="number">0xc3d4</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_VERDEFNUM&#x27;</span>],d_val=<span class="number">1</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_VERNEED&#x27;</span>],d_val=<span class="number">0xC3f0</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_VERNEEDNUM&#x27;</span>],d_val=<span class="number">2</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      dyn_data = self.structs.Elf_Dyn.build(<span class="built_in">dict</span>(d_tag=ENUM_D_TAG[<span class="string">&#x27;DT_NULL&#x27;</span>],d_val=<span class="number">0x0</span>))</span><br><span class="line">      dyn = self.structs.Elf_Dyn.parse(dyn_data)</span><br><span class="line">      self.dyns.append(dyn_data)</span><br><span class="line">      print(dyn)</span><br><span class="line"></span><br><span class="line">      print(<span class="string">&quot;+++dynamic count:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(self.dyns)))</span><br></pre></td></tr></table></figure>
<p>来看下重建后的内容：</p>
<img src="/images/sodump_oaid_dynamic_fixed.png" class="">


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们通过修复一个被严重破坏后的ELF文件，重新温习了ELF文件的各个关键结构。现在来看下整体修复成果：</p>
<img src="/images/sodump_oaid_exports.png" class="">

<p>这个JNI前面好像有点奇怪，其实是正常的，关于JNI签名的详细内容可参考<a href="/2021/12/21/JNI-Function-Name-Override/" title="JNI 方法注册和签名">JNI 方法注册和签名</a>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://refspecs.linuxfoundation.org/LSB_3.0.0/LSB-PDA/LSB-PDA.junk/symversion.html">Symbol Versioning</a></li>
<li><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-261585.htm">ARM栈回溯——从理论到实践，开发ida-arm-unwind-plugin</a></li>
</ul>

      
    </div>
    <footer>
      
        
  
  <div class="categories">
    <a href="/categories/Reverse-Engineering/">Reverse Engineering</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/android/">android</a>, <a href="/tags/arm/">arm</a>, <a href="/tags/elf/">elf</a>
  </div>

        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
      
<div id="gitalk-container"></div>   
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '15e82eced18a4f3699f5',
        clientSecret: '9159132c67a2722bbee0d59ff3026bb361bcd81c',
        repo: 'tatamobile_commnets',
        owner: 'vforkliu',
        admin: ["vforkliu"],
        id: '2022-02-23 20:52:22',
        title: '重学ELF文件格式',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });
    gitalk.render('gitalk-container');
</script>
      
  
</section>



  <nav id="postnav">
    
    
      <p>上一篇 : <a href="/2022/05/05/Inside-CMake-1-FindPkgConfig/" >深入理解CMake（一）: FindPkgConfig</a></p>
    
   
    
      <p>下一篇 : <a href="/2022/02/10/Android-Application-Protector-Calculate-module-itself-load-base-address/" >如何快速计算Android进程模块自身的加载基地址？</a></p>
    
    
    <div class="clearfix"></div>
  </nav>
</div></div>
    <aside id="sidebar" class="alignright">
        
    <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="as_sitesearch" value="tatamobile.net">
  </form>
</div>


    
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/CMake/">CMake</a><small>1</small></li>
  
    <li><a href="/categories/Python/">Python</a><small>2</small></li>
  
    <li><a href="/categories/Qt/">Qt</a><small>1</small></li>
  
    <li><a href="/categories/Reverse-Engineering/">Reverse Engineering</a><small>5</small></li>
  
  </ul>
</div>


    
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/C/">C++</a><small>1</small></li>
  
    <li><a href="/tags/CMake/">CMake</a><small>1</small></li>
  
    <li><a href="/tags/Decorator/">Decorator</a><small>1</small></li>
  
    <li><a href="/tags/Metaclass/">Metaclass</a><small>1</small></li>
  
    <li><a href="/tags/Python/">Python</a><small>2</small></li>
  
    <li><a href="/tags/Qt/">Qt</a><small>1</small></li>
  
    <li><a href="/tags/android/">android</a><small>3</small></li>
  
    <li><a href="/tags/arm/">arm</a><small>4</small></li>
  
    <li><a href="/tags/elf/">elf</a><small>1</small></li>
  
    <li><a href="/tags/java/">java</a><small>1</small></li>
  
    <li><a href="/tags/jni/">jni</a><small>1</small></li>
  
    <li><a href="/tags/markdown/">markdown</a><small>1</small></li>
  
    <li><a href="/tags/unicorn/">unicorn</a><small>1</small></li>
  
  </ul>
</div>


        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6011041061943855" crossorigin="anonymous"></script>
        <!-- 侧边栏广告 -->
        <ins class="adsbygoogle"
            style="display:block"
            data-ad-client="ca-pub-6011041061943855"
            data-ad-slot="2644505017"
            data-ad-format="auto"
            data-full-width-responsive="true"></ins>
        <script>
            (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
    </aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2024 TATAMOBILE|<a href="http://beian.miit.gov.cn/"; target=_blank>粤ICP备2020090023号</a>|<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44030902002346">粤公网安备 44030902002346号</a>
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script>
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
